<!DOCTYPE html>
<html lang="en">
<head>

    <!--Coded by Naoto Isayama -->

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-RJ8SVP1XLV"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-RJ8SVP1XLV');
        </script>

        <!--metadata-->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="Blackthorn Tattoo Ink is a fictional tattoo company based in Edmonton, Alberta, founded by award winning artist, Emily Blackthorn">
        <meta name="format-detection" content="telephone=no"> <!--Prevents Safari Default Styling-->
    
        <!-- Social Media Tags -->
        <meta property="og:title" content="BlackThorn Tattoo">
        <meta property="og:description" content="Fictional Tattoo company in Edmonton Alberta">
        <meta property="og:image" content="[]"><!--ADD THIS WHEN HOSTING-->
        <meta property="og:url" content="[Your Website URL]"> <!--ADD THIS WHEN HOSTING-->
        
        <title>Blackthorn Tattoo Ink | Book A Appointment</title>

        <!--css-->
        <link rel="stylesheet" type="text/css" href="styles.css">

        <!--Baskerville SC-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Baskervville+SC:wght@400..700&display=swap" rel="stylesheet">

        <!--Young Serif-->
        <link href="https://fonts.googleapis.com/css2?family=Young+Serif&display=swap" rel="stylesheet">

        <!--Fav Icon-->
        <link rel="icon" type="image/png" sizes="32x32" href="images/Vector-1.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicons/Vector.png">
        <link rel="icon" type="image/png" sizes="48x48" href="favicons/Vector-2.png">

        <!-- Flatpickr CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

        <!--Lucide CDN import-->
        <script src="https://unpkg.com/lucide@latest"></script>
</head>
    <body>

        <!--MOBILE NAV-->
        <header id="mobileNav">
            <div class="mobileNav__options">
            <a id="mobileNav__logo-link" class="border-box" href="index.html">
                <img src="images/logo4.png" id="mobileNav__logo-image" alt="">
            </a>

            <label class="hamburger-menu border-box" for="hamburger-checkbox">
                <input id="hamburger-checkbox" class="hamburger-checkbox" type="checkbox">
            </label> 
            

            <!--Change nav to aside-->
            <nav class="side-menu">
                <ul class="side-menu__nav-links">
                    <li class="sc-title light"><a aria-label="Go to Gallery Page" href="portfolio.html">Portfolio</a></li>
                    <li class="sc-title light"><a aria-label="Go to Flash store Page" href="flashstore.html">Flash</a></li>
                    <li class="sc-title light"><a aria-label="Go to About Us Page" href="aftercare.html">Aftercare</a></li>
                    <li class="sc-title light"><a aria-label="Go to Contact Page" href="form.html">Book</a></li>
                </ul>
            </nav>   
            </div>
        </header>

        <nav class="nav-padding desktop-nav undo-absolute page-nav bg-dark">
            <a href="/index.html"><img id="footer-logo" src="images/logo4.png"></a>
            <a class="sc-body light" href="/portfolio.html">Portfolio</a>
            <a class="sc-body light" href="/flashstore.html">Flash</a>
            <a class="sc-body light" href="/aftercare.html">Aftercare</a>
            <a class="sc-body light" href="/form.html">Book</a>
        </nav>

        <div class="marquee form-hide-marquee">
            <div class="marquee__inner-el">
                <span class="marquee-font span1">BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO •</span>
                <span class="marquee-font span2">BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO • BOOK NOW • EDMONTON • TATTOO •</span>
            </div>
        </div>

        <section class="contact fade-section" id="contact">
        <div class="form__flex-container">
            <div class="form__image-container">
                <!--<img id="form-image" src="images/form-img.webp">-->
            </div>
            <div class="form__form-container form-padding">
                <img id="form__flowers-overlay" src="images/flowers-overlay-1.png" alt="an overlay image of flowers">
                <h2 class="sc-subtitle fade" data-speed="fast">Book an <span class="rose">appointment</span></h2>
                
                <p class="body dev-message-form" data-speed="fast"><i data-lucide="message-circle-warning" id="warning-bubble"></i>  Please note! This form has submissions disabled, since this is a public demo website. -Naoto
                </p>
                <p id="submit-message" class="submit-message sc-medium">Thanks for Reaching out! <br>(In a full version, the client will get a email confirmation, and you get a email with all the relevant info)</p>
                <form method="post">
                    <!--Name Input-->
                    <div class="form-line fade" data-speed="medium">
                        <label class="sc-medium block">Name</label>
                        <input class="sc-body" placeholder="Your Name">
                    </div>

                    <!--Phone number Input-->
                    <div class="form-line fade" data-speed="medium">
                        <label class="sc-medium block">Phone Number</label>
                        <input class="sc-body" placeholder="Your Phone Number">
                    </div>

                    <!--Email Input-->
                    <div class="form-line fade" data-speed="medium">
                        <label class="sc-medium block">Email</label>
                        <input class="sc-body" placeholder="Your Email">
                    </div>

                        <!--Tattoo Placement Dropdown Menu !!! CONSIDER REPLACEING W/ CHECKBOX-->
                        <div class="form-line fade">
                            <label class="sc-medium block" for="tattoo-location">Tattoo Placement</label>
                            <select class="sc-body" id="tattoo-location" name="tattoo-location" required>
                                <option class="sc-body" value="" disabled selected>Select placement</option>
                                <option class="sc-body" value="shoulder">Shoulder/Upper Arm</option>
                                <option class="sc-body" value="other">Forearm</option>
                                <option class="sc-body" value="other">Upper Back</option>
                            </select>
                        </div>

                    <!--Tattoo location Dropdown Menu !!! CONSIDER REPLACEING W/ CHECKBOX-->
                    <!--Currently have hardcoded values but I will need to eventually implement a dynamic way to 
                    get values  -->
                    <div class="form-line fade">
                        <label class="sc-medium block" for="tattoo-location">Your Location</label>
                        <select class="sc-body" id="tattoo-city" name="tattoo-location" required>
                            <option class="sc-body" value="" disabled selected>Select City</option>
                            <option class="sc-body" value="Edmonton">Edmonton</option>
                            <option class="sc-body" value="Vancouver">Vancouver</option>
                            <option class="sc-body" value="Montreal">Montreal</option>
                        </select>
                    </div>
                    
                    <!--Tattoo Details Input-->
                    <div class="form-line fade" data-speed="medium">
                        <label class="sc-medium block">Brief Description of your tattoo</label>
                        <textarea rows="3" class="sc-body" placeholder="I want a dragon tattoo..."></textarea>
                    </div>
                    
                    <!--Reference Photos-->
                    <div class="form-line ref-photos fade" data-speed="medium">
                        <label class="sc-medium block reference-photos-title">Reference Photos</label>
                        <label class="sc-body custom-file-upload-1" for="reference-photos1">
                            <span class="sc-body custom-file-upload__btn-text-1"> Reference Photo 1</span>
                            <input type="file" id="reference-photos1" name="reference-photos[]" accept="image/*" multiple>
                        </label>
                        <label class="sc-body custom-file-upload-2" for="reference-photos2">
                            <span class="sc-body custom-file-upload__btn-text-2">Reference Photo 2</span>
                            <input type="file" id="reference-photos2" name="reference-photos[]" accept="image/*" multiple>
                        </label>
                        <label class="sc-body custom-file-upload-3" for="reference-photos3">
                            <span class="sc-body custom-file-upload__btn-text-3">Reference Photo 3</span>
                            <input type="file" id="reference-photos3" name="reference-photos[]" accept="image/*" multiple>
                        </label>
                    </div>

                    <!--Date picker-->
                    <div class="form-line fade" data-speed="medium">
                        <label class="sc-medium block" for="appointment-date">Appointment Date (Please Read Below!)</label>
                        <!--<span class="dev-note body dark">The dates on this calendar are controlled by a private scheduling dashboard, and what the user chooses as their location above. For this example, this artist works Mon-Fri in Edmonton, and is going to Vancouver from September 22nd-26th. As well, this artist has booked appointments on Sept 29th, Oct 2nd, and Oct 8th. Switch between the two location options above to see the changes on the calendar. If you're interested in seeing how this dashboard works, shoot me an email!-Naoto</span>-->
                        <div class="date-picker" id="date-picker-el" data-id="datetime">
                            <input class="sc-body" type="text" id="appointment-date" name="appointment-date" placeholder="Select a Location First" data-input>
                            <button type="button" class="calendar-button" title="toggle" data-toggle>
                                <i data-lucide="calendar"></i>
                            </button>
                        </div>
                    </div>

                    <!--time blocks-->
                    <div class="form-line time-blocks-grid fade" data-speed="medium">
                        <label class="sc-medium block reference-photos-title">Select a time</label>
                        
                        <!--Example Time Slot Button, delete later
                        <label class="time-block borderred">
                            <input type = "radio" name="timeBlock" value="9:00-10:30">
                            9:00-10:30
                        </label>-->

                    </div>

                    <button id="submit-button" type="submit" class="button sc-medium fade" data-speed="slow">SUBMIT</button>
                </form>
            </div>
        </div>
    </section>

    <footer class="side-padding">
        <div class="footer-top">
            <img id="footer-logo" src="images/logo4_black.png">
            <span><a id="personal-link" href="https://www.naotoisayama.com">Designed By Naoto Isayama</a></span>
        </div>
        <div class="divider"></div>
        <div>
            <span class="copyright">© 2025 Blackthorn Tattoo. All rights reserved</span>
        </div>
    </footer>

    <!--scripts-->
    <script src="updateFileUpload.js"></script>
    <script src="submithandler.js"></script>
    <script src="sectionObserver.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script><!-- Flatpickr JS -->

    <!--
    <script>
        window.addEventListener('DOMContentLoaded', async () => {

            /* TO DO LIST 

            2025-09-29: Next step is to find a way to block off booked days only when all the hours are booked. 
            Otherwise, the getHours() function needs to be able to take a time range from bookedDates(if one exists for the selected day)
            subtract it from the total range, and create time blocks in the new range.
            */

            let n = 90; // Represents the time needed to do the flash tattoo. Grab from metadata later

            lucide.createIcons(); // replaces all data-lucide icons with SVGs

            // Send POST request on page load
            const response = await fetch('https://blackthorntattoo.naotoisayama.com/.netlify/functions/getAvailability', {
                method: 'POST',
            })
            const data = await response.json();
            window.availabilityData = data;


            // 1. EXTRACT WEEKLY SCHEDULE INTO ARRAY
                // Console logs
            //console.log('window.availabilityData is', window.availabilityData);

                // Console.log of weeklySchedule
            //console.log('weeklyScheduleArray is', window.availabilityData.weeklySchedule);

            let weeklyScheduleArray = window.availabilityData.weeklySchedule; //Extract out the 'weeklySchedule' array for better readability
            let weeklyScheduleObject = weeklyScheduleArray[0];

            const homeCity = weeklyScheduleArray[0].homeCity; // weeklySchedule Array should just be size 1, look into adding restrictions in sanity studio
            const scheduledDaysArray = weeklyScheduleArray[0].weekdays.flatMap(s => s.day); // Get scheduled days into a flattened 1-D array

                // Console.log of weeklySchedule *check
            //console.log(`Weekly Schedule Array Data is : ${scheduledDaysArray} after processing`);

                // Console.log HOMECITY
            //console.log('Home City is: ', homeCity);


            // 2.. EXTRACT ROAD TRIP DATA INTO ARRAY
            // Console log extracted
            const roadTrips = window.availabilityData.roadTrips
            //console.log('roadTrips is', roadTrips);
































            // 3.. EXTRACT BLOCKED DATES INTO ARRAY
            /* Notes on this subsection: The only weird issue is that the final forEach block will produce duplicate
            bookedDays. */

            //console.log('window.availabilityData.blockedDates is', window.availabilityData.bookedDays);

            let fullyBooked = []; // This Array should hold the fully booked days, where any gap < n
            let partiallyBooked = []; // This Array should hold the new availability of days that are partially booked, for use later
            let bookedDateObj;
            let roadTripRangesArr = [];


            const bookedDatesArray = window.availabilityData.bookedDays.map(b => b.date); // Array of date strings
            const bookedDateObjArr = window.availabilityData.bookedDays; // Array of the objects themselves

            //console.log("bookedDatesArray is: ", bookedDatesArray);

            // ------ HELPER FUNCTIONS ------ //
            //Date Parser is a function that splits up the date string so that date() objects created with it 
            //dont apply the stupid fucking timezone shift
            function dateParser(dateStr) {
                // Expecting format YYYY-MM-DD
                const [year, month, day] = dateStr.split("-").map(Number);
                return [year, month, day];
            }

            function timeToMinutes(timeStr) {
                const [hours, mins] = timeStr.split(":").map(Number);
                return hours * 60 + mins;           
            }

            // Merge intervals merges all the appointment time ranges in a day into the least amount of consolidated
            // time blocks for easier calculations
            function mergeIntervals(bookedSlots) {

                if (bookedSlots.length == 1) {
                    const merged = [bookedSlots[0]];
                    return merged;
                }

                // first, sort array by start time
                bookedSlots.sort((a, b) => a[0] - b[0]);

                // Merged holds a array of consolidated intervals, populate it with first interval
                const merged = [bookedSlots[0]]; //bookedSlots[0] is a array of size 2

                // Loop over booked slots, starting at the second item, check if start time is = or < the end time of
                // the previous item

                for (let i = 1; i < bookedSlots.length; i++) {
                    let lastMerged = merged[merged.length - 1];

                    // Check if the start time of the current slot is less than
                    // or equal to the end time of the previous merged slot. If so,
                    // merge that array
                    if (bookedSlots[i][0] <= lastMerged[1]) {
                        lastMerged[1] = Math.max(lastMerged[1], bookedSlots[i][1]); // Set endpoint to whichever endpoint is later
                    } else {
                        merged.push(bookedSlots[i]);
                    }

                    return merged;
                }
            }

            // getFreeSlots takes a schedule {startTime, endTime} and a mergedIntervals [[start, end], ...] and returns
            // an array an array of objects [{start:, end:}, ...] that represents the free slots on a given booked day.
            function getFreeSlots (schedule, mergedIntervals) {
                const scheduleStart = schedule.startTime;
                const scheduleEnd = schedule.endTime;

                const freeSlots = [];
                let cursor = scheduleStart;

                // interval[0] represents the start time, interval[1] represents the end time
                for (let interval of mergedIntervals) {
                    if (interval[0] > cursor) {
                        freeSlots.push({
                            start: cursor,
                            end: interval[0]
                        });
                    }
                    cursor = interval[1];
                }

                // Once the loop is done, add the gap between cursor and scheduleEnd, if it exists
                if (cursor < scheduleEnd) {
                    freeSlots.push({
                        start: cursor,
                        end: scheduleEnd
                    });
                }

                return freeSlots;
            }

            // isFullyBooked see's if a n-sized block can fit inside freeSlots, essentially determining if a
            // day is fully booked, for this kind of appointment
            function isFullyBooked(freeSlots, n) {
                // If there are no free slots (freeSlots array is empty), early exit
                if (freeSlots.length == 0) {
                    return true;
                }

                // .every() return true/false only if every element passes the testing function
                // So here, if every free slot is smaller than n, isFullyBooked = true
                return freeSlots.every(slot => slot.end - slot.start < n);
            }

            // ------ END HELPER FUNCTIONS ------ //


            // Loop through all roadtrips and extract out date ranges as Date() objects
            roadTrips.forEach(t => {
                roadTripRangesArr.push({
                    city: t.trip.city,
                    start: new Date(dateParser(t.trip.startDate)), 
                    end: new Date(dateParser(t.trip.endDate)),
                    timeSlot: t.trip.timeSlot
                })
            });

            // console.log("roadTripRangesArr is: ", roadTripRangesArr);
            bookedDateObjArr.forEach(obj => {
                // Convert Time slots to minutes
                obj.timeSlot = {
                    startTime: timeToMinutes(obj.timeSlot.startTime),
                    endTime: timeToMinutes(obj.timeSlot.endTime)
                };
            })

            // Loop through all booked Dates and check each one for which range they fit into
            bookedDateObjArr.forEach(obj => {
                bookedDateObj = new Date(dateParser(obj.date));

                // console.log("bookedDateObj is: ", bookedDateObj);
                
                let bookedDateRoadTrip = roadTripRangesArr.find(t => {
                    return bookedDateObj >= t.start && bookedDateObj <= t.end
                });

                // find all bookings on that day 
                // bookingsOnDate is currently a array of objects
                let bookingsOnDate = bookedDateObjArr.filter(b => b.date === obj.date);
                //console.log("bookingsOnDate is: ", bookingsOnDate);


                // create array of 2d arrays, each of which is [startTime, endTime]
                let intervals = [];

                for (let obj of bookingsOnDate) {
                    let item = [];
                    item.push(obj.timeSlot.startTime, obj.timeSlot.endTime);
                    intervals.push(item);
                }

                //console.log("Intervals is: ", intervals);

                // Merge all bookings on the same day into min amount of blocks

                const mergedIntervals = mergeIntervals(intervals);

                //console.log("bookingsOnDate after minutes conversions is: ", bookingsOnDate);

                let scheduleForDay;

                // You can move out the shared code outside this if-else block
                if (bookedDateRoadTrip) {

                    // Pulling Schedule from road trip, translate time slots data into minutes
                    scheduleForDay = {
                        startTime: timeToMinutes(bookedDateRoadTrip.timeSlot.startTime),
                        endTime: timeToMinutes(bookedDateRoadTrip.timeSlot.endTime)
                    };

                    //console.log("City Schedule for day is: ", scheduleForDay);

                    let bookedDateFreeSlots = getFreeSlots(scheduleForDay, mergedIntervals);

                    // If the date is fully booked, then push only the date to fullyBooked, if not push the array of free slots to partially booked
                    isFullyBooked(bookedDateFreeSlots, n) ? fullyBooked.push(bookedDateObj) : partiallyBooked.push({date: obj.date, slots : bookedDateFreeSlots});

                    //console.log(`bookedDateFreeSlots for ${bookedDateObj} in ${bookedDateRoadTrip.city} is: `, bookedDateFreeSlots);

                } else {
                    //console.log("weeklySchedule object is: ", weeklyScheduleObject);
                    
                    // Find the correct weekday {day, endTime, startTime}
                    weekdaysObject = weeklyScheduleObject.weekdays.find(s => s.day == bookedDateObj.getDay());

                    scheduleForDay = {
                        startTime: timeToMinutes(weekdaysObject.startTime),
                        endTime: timeToMinutes(weekdaysObject.endTime)
                    }

                    let bookedDateFreeSlots = getFreeSlots(scheduleForDay, mergedIntervals);

                    isFullyBooked(bookedDateFreeSlots, n) ? fullyBooked.push(bookedDateObj) : partiallyBooked.push({date: obj.date, slots : bookedDateFreeSlots});

                    //console.log("Home Schedule for day is: ", scheduleForDay);
                    //console.log(`bookedDateFreeSlots for ${bookedDateObj} in Edmonton is: `, bookedDateFreeSlots);
                }
            });

            // remove duplicates from partiallyBooked by converting to a map, then convert it back
            const tempMap = new Map();
            partiallyBooked.forEach(obj => tempMap.set(obj.date, obj));
            //console.log("tempMap is: ", tempMap);
            partiallyBooked = Array.from(tempMap.values());


            //console.log("The array of fully booked dates is: ", fullyBooked);
            console.log("The array of partially booked dates is: ", partiallyBooked);



















            // 4... IMPLEMENT LOGIC FOR LOCATION-BASED FILTERING
            let selectedValue;
            let selectedTrip;
            const dropdown = document.getElementById("tattoo-city");
            let today = new Date();
            let twelveMonths = new Date();
            twelveMonths.setMonth(today.getMonth() + 6);
            const grid = document.querySelector(".time-blocks-grid");

            //init flatpickr first
            const calendarInstance = flatpickr("#date-picker-el", {
                dateFormat: "Y-m-d",
                minDate: "today",
                wrap: true,
                onChange: (selectedDates, dateStr, instance) => {
                    console.log('selectedDates[0] is: ', selectedDates[0]);
                    if (selectedDates[0]) {
                        getHours(selectedDates[0], dropdown.value);
                    }
                }
            });

            // Write function that returns 'false' if date is not in scheduledDaysArray
            // getDay() return the numerical representation of the day of the week, convert it
            // to string since 'scheduledDaysArray' consists of strings

            const recurringDisabledWeekdays = (date) => {
                return !(scheduledDaysArray.includes(date.getDay().toString()));
            }


            // Dropdown menu event listener, The initialization for flatpickr is inside here
            dropdown.addEventListener("change", () => {

                // Clear calendar
                calendarInstance.clear()

                // Clear grid
                const oldBlocks = grid.querySelectorAll(".time-block");
                oldBlocks.forEach(block => block.remove());

                // Dropdown option selected
                selectedValue = dropdown.value;

                //console log
                //console.log('selectedValue is: ', selectedValue);

                // If selected Value is home city, display schedule - (trip dates + bookedDays)
                // console log comparison
                /*
                console.log('The truth value of selectedValue = homeCity is: ', selectedValue === homeCity);
                console.log('The data type of selectedValue is: ', typeof selectedValue);
                console.log('The data type of homeCity is: ', typeof homeCity);*/
                
                const flatpickrArray = [];
                flatpickrArray.push(...fullyBooked);

                if (selectedValue === homeCity) {

                    // Loop through road trips, and push a range object to disable array
                    for (let i =  0; i < roadTrips.length; i++) {
                        flatpickrArray.push({
                            from: roadTrips[i].trip.startDate,
                            to: roadTrips[i].trip.endDate
                        })
                    }
                    
                    /* Add booked dates array to disabled
                    for (let i = 0; i < bookedDatesArray.length; i++) {
                        flatpickrArray.push(bookedDatesArray[i]);
                    }*/

                    //console.log('The Disabled array, after adding trips and booked dates is: ', flatpickrArray); 

                    calendarInstance.set("disable", [...flatpickrArray, recurringDisabledWeekdays]);
                    calendarInstance.set("minDate", today);

                } else {
                    
                    let startDateObj;

                    // Find which trip is selected and disable today -> startOfTrip && endOfTrip -> 3 months
                    for (let i = 0; i < roadTrips.length; i++) {
                        if (roadTrips[i].trip.city === selectedValue) {

                            //console.log("The Start of the strip is: ", roadTrips[i].trip.startDate);
                            //console.log("The End of the strip is: ", roadTrips[i].trip.endDate);

                            // today -> startOfTrip

                            // randomly convert to dat obj
                            startDateObj = new Date(roadTrips[i].trip.startDate);

                            // from is inclusive, so go today -1
                            today.setDate(today.getDate()-1);

                            flatpickrArray.push({
                                from: today,
                                to: startDateObj
                            });

                            // endOfTrip -> 3 months
                            const endDateObj = new Date(roadTrips[i].trip.endDate);
                            endDateObj.setDate(endDateObj.getDate() + 1);

                            flatpickrArray.push({
                                from: endDateObj,
                                to: twelveMonths
                            });
                        }
                    }

                    calendarInstance.set("disable", [...flatpickrArray]);
                    calendarInstance.set("minDate", startDateObj);
                }
            });


            // 5. FROM SELECTED DATE, GET HOUR RANGE

            // Console log date range for selected day
            let city = dropdown.value;



            //-------- HELPER FUNCTIONS ------//
            // timeDiff calculates the time difference between 2 24-hr strings and returns the
            // start and end times, expressed as minutes since midnight
            function timeDiff(start, end) {
                const [startHours, startMins] = start.split(":").map(Number);
                const [endHours, endMinutes] = end.split(":").map(Number);

                // Convert both to minutes since midnight
                const startDelta = startHours * 60 + startMins;
                const endDelta = endHours * 60 + endMinutes;

                // return diff, startDelta and endDelta
                return {
                    delta: endDelta - startDelta,
                    start: startDelta,
                    end: endDelta
                }
            }  
            
            // VIBE CODED. Translates minutes from midnight to 24hr xx:xx format
            function formatTimeRange(time1, time2) {
                function minutesTo24Hour(minutes) {
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    // pad with leading 0
                    const hh = hours.toString().padStart(2, "0");
                    const mm = mins.toString().padStart(2, "0");
                    return `${hh}:${mm}`;
                }
                return `${minutesTo24Hour(time1)}-${minutesTo24Hour(time2)}`;
            }

            // Takes a 24 hour string, converts it into minutes since midnight
            function minutesFrom24Hour(time) {
                const [hours, mins] = time.split(":").map(Number);
                return hours * 60 + mins;
            }

            //-------- HELPER FUNCTIONS ------//

            // Get hours is a function that takes a date string (chosen by the user via flatpickr)
            // and a city (chosen by the user in the dropdown) and creates a grid of buttons, corresponding to
            // available time blocks of size n (n being the time needed to do the flash tattoo)
            function getHours(dateObj, city) {

                //clear all old blocks
                const oldBlocks = grid.querySelectorAll(".time-block");
                oldBlocks.forEach(block => block.remove());

                const dateWeekday = dateObj.getDay();
                let timeChunks = [];
                let slots = [];
                let isPartial = false; 

                // Check if dateObj matches with any date from the objects in partiallyBooked
                // and save its slots data and set isPartial to true

                // Convert dateObj into a date string
                const dateStr = dateObj.toISOString().split("T")[0];

                for (let obj of partiallyBooked) {
                    if (dateStr == obj.date) {
                        isPartial = true;
                        slots.push(...obj.slots);
                    }
                }

                // Since the city is already selected, we can grab the schedule based on that choice
                if (city === homeCity) {
                    if (isPartial) {
                        console.log("slots is: ", slots);
                        // Loop through each timeslot, and find how many n-sized chunks fit inside
                        for (let slot of slots) {
                            let slotDelta = slot.end - slot.start;
                            for (let i = 0; i < slotDelta/n; i++){
                                if ((n + (n * i)) <= slotDelta) {
                                    timeChunks.push({
                                        start: slot.start + (n * i),
                                        end: (slot.start + n) + (n * i)
                                    });
                                }   
                            }
                        } 
                        generateGrid(timeChunks);
                        console.log("timeChunks after looping through the slots is: ", timeChunks);
                    } 
                    else {  
                        //alert("getHours() fired, main branch");

                        // console.log("dateWeekday is: ", dateWeekday);
                        // console.log("weeklyScheduleObject is: ", weeklyScheduleObject);
                        let weekday = weeklyScheduleObject.weekdays[dateWeekday];

                        // in minutes
                        let timeDiffObj = timeDiff(weekday.startTime, weekday.endTime)

                        console.log("The time range is: ", timeDiffObj.delta, " minutes.");
                        // Here, set n to be the size (in minutes) you want the time chunks to be
                        
                        // This loop calculates how many N sized chunks fit in the available time
                        // Each object in timeChunks represents the time blocks (minutes since Midnight)
                        // that are available
                        for (let i = 0; i < (timeDiffObj.delta/n); i++) {
                            if ((n + (n * i)) <= timeDiffObj.delta) { // This conditional checks if the 'end' of the next iteration exceeds the end of the artists working hours
                                timeChunks.push({
                                    start: timeDiffObj.start + (n * i),
                                    end: (timeDiffObj.start + n) + (n * i)
                                })
                            }
                        }

                        console.log("timeChunks is: ", timeChunks);

                        generateGrid(timeChunks)
                    }
                } 
                else {
                    if (isPartial) { // Since get free slots generates free slots based on a schedule, if is partial code can be repeated
                        console.log("slots is: ", slots);
                        // Loop through each timeslot, and find how many n-sized chunks fit inside
                        for (let slot of slots) {
                            let slotDelta = slot.end - slot.start;
                            for (let i = 0; i < slotDelta/n; i++){
                                if ((n + (n * i)) <= slotDelta) {
                                    timeChunks.push({
                                        start: slot.start + (n * i),
                                        end: (slot.start + n) + (n * i)
                                    });
                                }   
                            }
                        } 
                        generateGrid(timeChunks);
                        console.log("timeChunks after looping through the slots is: ", timeChunks);
                    }
                    else {
                        // Write code for road trip city

                        // Find city name in roadTrips
                        let timeDiffObj; 

                        roadTrips.forEach(item => {
                            if (item.trip.city === city) {
                                timeDiffObj = timeDiff(item.trip.timeSlot.startTime, item.trip.timeSlot.endTime)
                            }
                        });

                        console.log("timeDiffObj for the road trip is: ", timeDiffObj);

                        // MAKE A HELPER FUNCTION !!!

                        // This loop calculates how many N sized chunks fit in the available time
                        // Each object in timeChunks represents the time blocks (minutes since Midnight)
                        // that are available
                        for (let i = 0; i < (timeDiffObj.delta/n); i++) {
                            if ((n + (n * i)) <= timeDiffObj.delta) { // This conditional checks if the 'end' of the next iteration exceeds the end of the artists working hours
                                timeChunks.push({
                                    start: timeDiffObj.start + (n * i),
                                    end: (timeDiffObj.start + n) + (n * i)
                                })
                            }
                        }

                        console.log("timeChunks is: ", timeChunks);
                        generateGrid(timeChunks);
                    }
                }
            }

            // This functions generates the grid of radios based on timeChucnks
            function generateGrid(timeChunks) {
                timeChunks.forEach(block => {
                    //Create label
                    const label = document.createElement("label");
                    label.className = "time-block";

                    //Create radio input
                    const radioInput = document.createElement("input");
                    radioInput.type = "radio";
                    radioInput.name = "timeBlock";
                    radioInput.value = `${formatTimeRange(block.start, block.end)}`;
                    
                    //Create text span
                    const text = document.createElement("span");
                    text.textContent = `${formatTimeRange(block.start, block.end)}`;
                    
                    label.appendChild(radioInput);
                    label.appendChild(text);

                    grid.appendChild(label);
                })
            }
        })           
    </script>-->

    <script src="calendar.js"></script>

    </body>
</html>